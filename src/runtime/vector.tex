\nwfilename{vector.nw}\nwbegindocs{0}% -*- noweb-code-mode: c-mode -*-% ===> this file was generated automatically by noweave --- better not edit it
% $Id: vector.nw,v 2.7 2004/03/26 09:29:28 wlux Exp $
%
% Copyright (c) 2002-2004, Wolfgang Lux
% See ../LICENSE for the full license.
%
\subsection{Array library}
The \texttt{Array} library is based on a few C functions which use
tuples to implement vectors with zero-based indexing. All of these
functions are in fact actions in the IO monad in order to ensure a
proper sequentialization of the operations performed on the vector.

We use the string \texttt{"(,)"} as a constructor name for vectors
because this will make the printing code treat vectors as tuples.

\nwenddocs{}\nwbegincode{1}\sublabel{NW1uoGJ-2a1eQJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW1uoGJ-2a1eQJ-2}\nwenddeflinemarkup
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "debug.h"
#include "run.h"
#include "heap.h"
#include "stack.h"
#include "trail.h"
#include "eval.h"
#include "threads.h"
#include "trace.h"
#include "cam.h"

enum \{ VECTOR_TAG \};

static NodeInfo vector_info = \{
    VECTOR_TAG, 0, (const int *)0, (Label)eval_whnf, "(,)", (FinalFun)0
\};
static struct vector_node empty = \{
    &vector_info, vector_node_size(0), \{ \}
\};

\nwalsodefined{\\{NW1uoGJ-2a1eQJ-2}\\{NW1uoGJ-2a1eQJ-3}\\{NW1uoGJ-2a1eQJ-4}\\{NW1uoGJ-2a1eQJ-5}\\{NW1uoGJ-2a1eQJ-6}}\nwnotused{vector.c}\nwendcode{}\nwbegindocs{2}\nwdocspar
The action {\Tt{}newIOVector\nwendquote} allocates a new vector with a specified
size and assigns an initial value to every element of the vector.

\nwenddocs{}\nwbegincode{3}\sublabel{NW1uoGJ-2a1eQJ-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-2}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1uoGJ-2a1eQJ-1}{NW1uoGJ-2a1eQJ-3}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__newIOVector);

FUNCTION(__newIOVector)
\{
    long i, n;
    Node *init, *vec;

    EXPORT_LABEL(__newIOVector)
 ENTRY_LABEL(__newIOVector)
    EVAL_RIGID_INT(__newIOVector);
    n = int_val(sp[0]);
    if ( n < 0 )
    \{
        fprintf(stderr, "newIOVector: bad length (%ld)\\n", n);
        exit(2);
    \}

    if ( n == 0 )
        vec = (Node *)&empty;
    else
    \{
        CHECK_HEAP(vector_node_size(n));
        init = sp[1];
        while ( is_boxed(init) && is_indir_node(init) )
            init = init->n.node;
        vec           = (Node *)hp;
        vec->a.info   = &vector_info;
        vec->a.length = vector_node_size(n);
        for ( i = 0; i < n; i++ )
            vec->a.args[i] = init;
        hp += vector_node_size(n);
    \}

    sp += 3;
    RETURN(vec);
\}

\nwendcode{}\nwbegindocs{4}\nwdocspar
The action {\Tt{}copyIOVector\nwendquote} creates a copy of a vector. As it does not
contain any information, the empty vector can be shared and need not
be copied.

\nwenddocs{}\nwbegincode{5}\sublabel{NW1uoGJ-2a1eQJ-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-3}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1uoGJ-2a1eQJ-2}{NW1uoGJ-2a1eQJ-4}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__copyIOVector);

FUNCTION(__copyIOVector)
\{
    Node *vec;

    EXPORT_LABEL(__copyIOVector)
 ENTRY_LABEL(__copyIOVector)
    EVAL_RIGID(__copyIOVector);
    ASSERT(node_tag(sp[0]) == VECTOR_TAG);

    vec = sp[0];
    if ( vector_argc(vec) > 0 )
    \{
        CHECK_HEAP(vec->a.length);
        vec = (Node *)hp;
        memcpy(vec, sp[0], sp[0]->a.length * word_size);
        hp += vec->a.length;
    \}

    sp += 2;
    RETURN(vec);
\}

\nwendcode{}\nwbegindocs{6}\nwdocspar
The action {\Tt{}readIOVector\nwendquote} returns the $i$th element of a vector. If
the index is outside the range of the vector, the program is aborted.
The element is \emph{not} evaluated to head normal form as the IO
monad is lazy.

\nwenddocs{}\nwbegincode{7}\sublabel{NW1uoGJ-2a1eQJ-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-4}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1uoGJ-2a1eQJ-3}{NW1uoGJ-2a1eQJ-5}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__readIOVector);
DECLARE_LABEL(__readIOVector_1);

FUNCTION(__readIOVector)
\{
    Node *aux;

    EXPORT_LABEL(__readIOVector)
 ENTRY_LABEL(__readIOVector)
    EVAL_RIGID(__readIOVector);
    ASSERT(node_tag(sp[0]) == VECTOR_TAG);

    aux   = sp[0];
    sp[0] = sp[1];
    sp[1] = aux;
    GOTO(__readIOVector_1);
\}

static
FUNCTION(__readIOVector_1)
\{
    int  i;
    Node *vec, *r;

 ENTRY_LABEL(__readIOVector_1)
    EVAL_RIGID_INT(__readIOVector_1);

    i   = int_val(sp[0]);
    vec = sp[1];
    sp += 3;
    if ( i < 0 || (unsigned)i >= vector_argc(vec) )
    \{
        fprintf(stderr, "readIOVector: index out range (%d)\\n", i);
        exit(2);
    \}

    r = vec->a.args[i];
    RETURN(r);
\}

\nwendcode{}\nwbegindocs{8}\nwdocspar
The action {\Tt{}writeIOVector\nwendquote} updates the $i$th element of a vector. As
for {\Tt{}readIOVector\nwendquote}, the index must be checked before calling this
function.

\nwenddocs{}\nwbegincode{9}\sublabel{NW1uoGJ-2a1eQJ-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-5}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1uoGJ-2a1eQJ-4}{NW1uoGJ-2a1eQJ-6}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__writeIOVector);
DECLARE_LABEL(__writeIOVector_1);

FUNCTION(__writeIOVector)
\{
    Node *aux;

    EXPORT_LABEL(__writeIOVector)
 ENTRY_LABEL(__writeIOVector)
    EVAL_RIGID(__writeIOVector);
    ASSERT(node_tag(sp[0]) == VECTOR_TAG);

    aux   = sp[0];
    sp[0] = sp[1];
    sp[1] = aux;
    GOTO(__writeIOVector_1);
\}

static
FUNCTION(__writeIOVector_1)
\{
    int  i;
    Node *vec, *node;

 ENTRY_LABEL(__writeIOVector_1)
    EVAL_RIGID_INT(__writeIOVector_1);

    i    = int_val(sp[0]);
    vec  = sp[1];
    node = sp[2];
    sp  += 4;

    if ( i < 0 || (unsigned)i >= vector_argc(vec) )
    \{
        fprintf(stderr, "writeIOVector: index out range (%d)\\n", i);
        exit(2);
    \}

    SAVE(vec, a.args[i]);
    vec->a.args[i] = node;
    RETURN(unit);
\}

\nwendcode{}\nwbegindocs{10}\nwdocspar
The function {\Tt{}lengthIOVector\nwendquote} returns the length of a vector, i.e.,
the number of elements that can be stored in the vector. This function
is not a monadic action because the length of a vector does not
change.

\nwenddocs{}\nwbegincode{11}\sublabel{NW1uoGJ-2a1eQJ-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-6}}}\moddef{vector.c~{\nwtagstyle{}\subpageref{NW1uoGJ-2a1eQJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW1uoGJ-2a1eQJ-5}{\relax}\nwenddeflinemarkup
DECLARE_ENTRYPOINT(__lengthIOVector);

FUNCTION(__lengthIOVector)
\{
    int  n;
    Node *r;

    EXPORT_LABEL(__lengthIOVector)
 ENTRY_LABEL(__lengthIOVector)
    EVAL_RIGID(__lengthIOVector);
    ASSERT(node_tag(sp[0]) == VECTOR_TAG);

    n   = vector_argc(sp[0]);
    sp += 1;

#if ONLY_BOXED_OBJECTS
    CHECK_HEAP(int_node_size);
    r       = (Node *)hp;
    r->info = &int_info;
    r->i.i  = n;
    hp     += int_node_size;
#else
    r = mk_int(n);
#endif
    RETURN(r);
\}
\nwendcode{}

\nwixlogsorted{c}{{vector.c}{NW1uoGJ-2a1eQJ-1}{\nwixd{NW1uoGJ-2a1eQJ-1}\nwixd{NW1uoGJ-2a1eQJ-2}\nwixd{NW1uoGJ-2a1eQJ-3}\nwixd{NW1uoGJ-2a1eQJ-4}\nwixd{NW1uoGJ-2a1eQJ-5}\nwixd{NW1uoGJ-2a1eQJ-6}}}%

