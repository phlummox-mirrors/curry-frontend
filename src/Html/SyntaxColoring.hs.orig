module Html.SyntaxColoring
  ( Code (..), TypeUsage (..), ConsUsage (..)
  , IdentUsage (..), FuncUsage (..)
  , genProgram, code2string, getQualIdent
  ) where

import Data.Function (on)
import Data.List     (intercalate)

import Curry.Base.Ident
import Curry.Base.Position
import Curry.Syntax

import Base.Messages

data Code
  = Keyword     String
  | Space       Int
  | NewLine
  | Pragma      String
  | TypeCons    TypeUsage  QualIdent
  | DataCons    ConsUsage  QualIdent
  | Function    FuncUsage  QualIdent
  | Identifier  IdentUsage QualIdent
  | Label       LabelUsage QualIdent
  | ModuleName  ModuleIdent
  | Commentary  String
  | NumberCode  String
  | StringCode  String
  | CharCode    String
  | Symbol      String
    deriving Show

data TypeUsage
  = TypeDeclare
  | TypeRefer
  | TypeExport
  | TypeImport
    deriving Show

data ConsUsage
  = ConsDeclare
  | ConsPattern
  | ConsCall
  | ConsInfix
  | ConsExport
  | ConsImport
    deriving Show

data FuncUsage
  = FuncDeclare
  | FuncTypeSig
  | FuncCall
  | FuncInfix
  | FuncExport
  | FuncImport
    deriving Show

data IdentUsage
  = IdDeclare -- declare a (type) variable
  | IdRefer   -- refer to a (type) variable
  | IdUnknown -- unknown usage
    deriving Show

<<<<<<< HEAD
--- @param src
--- @param list with parse-Results with descending quality,
---        e.g. [typingParse, fullParse, parse]
--- @param lex-Result
--- @return program
genProgram :: String -> [MessageM Module] -> MessageM [(Position, Token)] -> Program
genProgram src parseResults lexed = case runMsg lexed of
  Left e -> buildMessagesIntoPlainText [e] src
  Right (posNtokList, mess) ->
    let messages = (prepareMessages (concatMap getMessages parseResults ++ mess))
        mergedMessages = (mergeMessages' (trace' ("Messages: " ++ show messages) messages) posNtokList)
        (nameList,codes) = catIdentifiers parseResults
    in tokenNcodes2codes nameList 1 1 mergedMessages codes

--- @param code
--- @return qid if available
getQualIdent :: Code -> Maybe QualIdent
getQualIdent (ConstructorName _ qid) = Just qid
getQualIdent (Function        _ qid) = Just qid
getQualIdent (Identifier      _ qid) = Just qid
getQualIdent (TypeConstructor _ qid) = Just qid
getQualIdent  _                      = Nothing

-- DEBUGGING----------- wird bald nicht mehr gebraucht

setMessagePosition :: Message -> Message
setMessagePosition m@(Message (Just p) _) = trace'' ("pos:" ++ show p ++ ":" ++ show m) m
setMessagePosition (Message _ m) =
        let mes@(Message pos _) =  (Message (getPositionFromString $ show m) m) in
        trace'' ("pos:" ++ show pos ++ ":" ++ show mes) mes

getPositionFromString :: String -> Maybe Position
getPositionFromString msg =
     if l > 0 && c > 0
          then Just Position{file=f,line=l,column=c,astRef=noRef}
          else Nothing
  where
      f = takeWhile (/= '"') (tail (dropWhile (/= '"') msg))
      l = readInt (takeWhile (/= '.') (drop 7 (dropWhile (/= ',') msg)))
      c = readInt (takeWhile (/= ':') (tail (dropWhile (/= '.') (drop 7 (dropWhile (/= ',') msg)))))


readInt :: String -> Int
readInt s =
      let onlyNum = filter isDigit s in
      if null onlyNum
         then 0
         else read onlyNum :: Int

flatCode :: Code -> Code
flatCode (CodeWarning _ code) = code
flatCode code                 = code

-- ----------Message---------------------------------------

getMessages :: MessageM a -> [Message]
getMessages = either return snd . runMsg --(Result mess _) = mess
-- getMessages (Failure mess) = mess

lessMessage :: Message -> Message -> Bool
lessMessage (Message mPos1 _) (Message mPos2 _) = mPos1 < mPos2

nubMessages :: [Message] -> [Message]
nubMessages = nubBy eqMessage

eqMessage :: Message -> Message -> Bool
eqMessage (Message p1 s1) (Message p2 s2) = (p1 == p2) && (show s1 == show s2)

prepareMessages :: [Message] -> [Message]
prepareMessages = qsort lessMessage . map setMessagePosition . nubMessages


buildMessagesIntoPlainText :: [Message] -> String -> Program
buildMessagesIntoPlainText messages src =
  buildMessagesIntoPlainText' messages (lines src) [] 1
 where
  buildMessagesIntoPlainText' :: [Message] -> [String] -> [String] -> Int -> Program
  buildMessagesIntoPlainText' _ [] [] _ =   []
  buildMessagesIntoPlainText' _ [] postStrs ln =
        [(ln, 1, NotParsed (unlines postStrs))]
  buildMessagesIntoPlainText' [] preStrs postStrs ln =
        [(ln, 1, NotParsed (unlines (preStrs ++ postStrs)))]

  buildMessagesIntoPlainText' messages1 (str:preStrs) postStrs ln =
        let (pre,post) = partition isLeq messages1 in
        if null pre
            then buildMessagesIntoPlainText' post preStrs (postStrs ++ [str]) (ln + 1)
            else (ln,1,NotParsed (unlines postStrs)) :
                (ln,1,CodeWarning pre (NotParsed str)) :
                (ln,1,NewLine) :
                buildMessagesIntoPlainText' post preStrs [] (ln + 1)
    where
    isLeq (Message (Just p) _) = line p <= ln
    isLeq _ = True

--- @param parse-Modules  [typingParse,fullParse,parse]
catIdentifiers :: [MessageM Module] -> ([(ModuleIdent, ModuleIdent)],[Code])
catIdentifiers = catIds . map fst . rights_sc . map runMsg
    where
      catIds [] = ([],[])
      catIds [m] =
          catIdentifiers' m Nothing
      catIds rs@(m:_:_) =
          catIdentifiers' (last rs) (Just m)

-- not in base befoer base4
rights_sc :: [Either a b] -> [b]
rights_sc es = [ x | Right x <- es]

--- @param parse-Module
--- @param Maybe betterParse-Module
catIdentifiers' :: Module -> Maybe Module -> ([(ModuleIdent,ModuleIdent)],[Code])
catIdentifiers' (Module mid maybeExportSpec is decls)
                Nothing =
      let impCodes = concatMap importDecl2codes (qsort lessImportDecl is)
          codes = (concatMap decl2codes (qsort lessDecl decls))
      in (concatMap renamedImports is,
      ModuleName mid :
       maybe [] exportSpec2codes maybeExportSpec ++ impCodes ++ codes)
catIdentifiers' (Module mid maybeExportSpec1 _ _)
                (Just (Module _ maybeExportSpec2 is decls)) =
      let impCodes = concatMap importDecl2codes (qsort lessImportDecl is)
          codes = (concatMap decl2codes (qsort lessDecl decls))
      in (concatMap renamedImports is,
      replaceFunctionCalls $
        map (addModuleIdent mid)
          ([ModuleName mid] ++
           mergeExports2codes
              (maybe [] (\(Exporting _ i) -> i)  maybeExportSpec1)
              (maybe [] (\(Exporting _ i) -> i)  maybeExportSpec2) ++
           impCodes ++ codes))

renamedImports :: ImportDecl -> [(ModuleIdent, ModuleIdent)]
renamedImports (ImportDecl _ oldName _ (Just newName) _) = [(oldName,newName)]
renamedImports _                                         = []

replaceFunctionCalls :: [Code] -> [Code]
replaceFunctionCalls codes = map (idOccur2functionCall qids) codes
   where qids = findFunctionDecls codes


findFunctionDecls :: [Code] -> [QualIdent]
findFunctionDecls = mapMaybe getQualIdent . filter Html.SyntaxColoring.isFunctionDecl . map flatCode

isFunctionDecl :: Code -> Bool
isFunctionDecl (Function FunDecl _) = True
isFunctionDecl _                    = False

idOccur2functionCall :: [QualIdent] -> Code -> Code
idOccur2functionCall qids ide@(Identifier IdOccur qid)
  | isQualified qid = Function FunctionCall qid
  | elem qid qids   = Function FunctionCall qid
  | otherwise       = ide
idOccur2functionCall qids (CodeWarning mess code) =
  CodeWarning mess (idOccur2functionCall qids code)
idOccur2functionCall _ code = code

=======
data LabelUsage
  = LabelDeclare
  | LabelRefer
    deriving Show
>>>>>>> master


-- @param list with parse-Results with descending quality,
--        e.g. [typingParse, fullParse, parse]
-- @param lex-Result
-- @return program
genProgram :: Module -> [(Position, Token)] -> [Code]
genProgram m toks = tokenToCodes (first "") (idsModule m) toks

-- @param code
-- @return qid if available
getQualIdent :: Code -> Maybe QualIdent
getQualIdent (DataCons    _ qid) = Just qid
getQualIdent (Function    _ qid) = Just qid
getQualIdent (Identifier  _ qid) = Just qid
getQualIdent (TypeCons    _ qid) = Just qid
getQualIdent  _                  = Nothing

tokenToCodes :: Position -> [Code] -> [(Position, Token)] -> [Code]
tokenToCodes _      _   []                     = []
tokenToCodes curPos ids toks@((pos, tok) : ts)
  -- advance line
  | line curPos < line pos
  = NewLine         : tokenToCodes (nl curPos) ids toks
  -- advance column
  | column curPos < column pos
  = Space colDiff   : tokenToCodes (incr curPos colDiff) ids toks
  | isPragmaToken tok
  = let (pragmas, (end:rest)) = break (isPragmaEnd . snd) toks
        pragmaStr       = intercalate " " $ map (showToken . snd) (pragmas ++ [end])
    in  Pragma pragmaStr : tokenToCodes (incr curPos (length pragmaStr)) ids rest
  -- no identifier token
  | not (isTokenIdentifier tok)
  = tokenToCode tok : tokenToCodes newPos ids ts
  -- identifier, but no more information
  | null ids
  = tokenToCode tok : tokenToCodes newPos ids ts
  | tokenStr == code2string (head ids)
  = head ids        : tokenToCodes newPos (tail ids) ts
  | otherwise
  = tokenToCodes curPos (tail ids) toks
  where
  colDiff  = column pos - column curPos
  tokenStr = showToken tok
  newPos   = incr curPos (length tokenStr)

code2string :: Code -> String
<<<<<<< HEAD
code2string (Keyword           s) = s
code2string (Space               i) = concat (replicate i " ")
code2string NewLine                 = "\n"
code2string (ConstructorName _ qid) = idName $ unqualify qid
code2string (TypeConstructor _ qid) = idName $ unqualify qid
code2string (Function        _ qid) = idName $ unqualify qid
code2string (ModuleName        mid) = moduleName mid
code2string (Commentary        s) = s
code2string (NumberCode        s) = s
code2string (StringCode        s) = s
code2string (CharCode          s) = s
code2string (Symbol            s) = s
code2string (Identifier      _ qid) = idName $ unqualify qid
code2string (CodeWarning       _ c) = code2string c
code2string (NotParsed         s) = s

code2qualString :: Code -> String
code2qualString (ConstructorName _ qid) = qualName qid
code2qualString (Function _ qid) = qualName qid
code2qualString (Identifier _ qid) = qualName qid
code2qualString (TypeConstructor _ qid) = qualName qid
code2qualString x = code2string x

token2code :: Token -> Code
token2code tok@(Token cat _)
  | elem cat [IntTok,FloatTok]
        = NumberCode (showToken tok)
  | elem cat [KW_case,KW_class,KW_data,KW_do,KW_else,KW_external,
              KW_free,KW_if,KW_import,KW_in,KW_infix,KW_infixl,KW_infixr,
              KW_instance, KW_let,KW_module,KW_newtype,KW_of,KW_then,KW_type,
              KW_where,Id_as,Id_ccall,Id_forall,Id_hiding,Id_interface,Id_primitive,
              Id_qualified]
        =  Keyword (showToken tok)
  | elem cat [LeftParen,RightParen,Semicolon,LeftBrace,RightBrace,LeftBracket,
              RightBracket,Comma,Underscore,Backquote,
              At,Colon,DotDot,DoubleColon,Equals,Backslash,Bar,LeftArrow,RightArrow,
              Tilde, DoubleArrow]
        = Symbol (showToken tok)
  | elem cat [LineComment, NestedComment]
        = Commentary (showToken tok)
  | isTokenIdentifier tok
        = Identifier UnknownId $ qualify $ mkIdent $ showToken tok
  | cat == StringTok
        = StringCode (showToken tok)
  | cat == CharTok
        = CharCode (showToken tok)
  | elem cat [EOF,VSemicolon,VRightBrace] = Space 0
  | otherwise = error "SyntaxColoring.token2code: no pattern match"
=======
code2string (Keyword         s) = s
code2string (Space           i) = concat (replicate i " ")
code2string NewLine             = "\n"
code2string (Pragma          s) = s
code2string (DataCons    _ qid) = idName $ unqualify qid
code2string (TypeCons    _ qid) = idName $ unqualify qid
code2string (Function    _ qid) = idName $ unqualify qid
code2string (Identifier  _ qid) = idName $ unqualify qid
code2string (Label       _ qid) = idName $ unqualify qid
code2string (ModuleName    mid) = moduleName mid
code2string (Commentary      s) = s
code2string (NumberCode      s) = s
code2string (StringCode      s) = s
code2string (CharCode        s) = s
code2string (Symbol          s) = s

tokenToCode :: Token -> Code
tokenToCode tok@(Token cat _)
  | cat `elem` numCategories          = NumberCode (showToken tok)
  | cat == CharTok                    = CharCode   (showToken tok)
  | cat == StringTok                  = StringCode (showToken tok)
  | cat `elem` keywordCategories      = Keyword    (showToken tok)
  | cat `elem` specialIdentCategories = Keyword    (showToken tok)
  | cat `elem` punctuationCategories  = Symbol     (showToken tok)
  | cat `elem` reservedOpsCategories  = Symbol     (showToken tok)
  | cat `elem` commentCategories      = Commentary (showToken tok)
  | cat `elem` identCategories        = Identifier IdUnknown $ qualify $ mkIdent
                                      $ showToken tok
  | cat `elem` whiteSpaceCategories   = Space 0
  | cat `elem` pragmaCategories       = Pragma     (showToken tok)
  | otherwise = error $ "SyntaxColoring.tokenToCode: " ++ showToken tok

numCategories :: [Category]
numCategories = [IntTok, FloatTok]

keywordCategories :: [Category]
keywordCategories =
  [ KW_case, KW_data, KW_do, KW_else, KW_external, KW_fcase, KW_foreign
  , KW_free, KW_if, KW_import, KW_in, KW_infix, KW_infixl, KW_infixr
  , KW_let, KW_module, KW_newtype, KW_of, KW_then, KW_type, KW_where
  ]

specialIdentCategories :: [Category]
specialIdentCategories =
  [ Id_as, Id_ccall, Id_forall, Id_hiding
  , Id_interface, Id_primitive, Id_qualified ]

punctuationCategories :: [Category]
punctuationCategories =
  [ LeftParen, RightParen, Semicolon, LeftBrace, RightBrace
  , LeftBracket, RightBracket, Comma, Underscore, Backquote ]

reservedOpsCategories :: [Category]
reservedOpsCategories =
  [ At, Colon, DotDot, DoubleColon, Equals, Backslash, Bar
  , LeftArrow, RightArrow, Tilde, Bind, Select ]

commentCategories :: [Category]
commentCategories = [LineComment, NestedComment]

identCategories :: [Category]
identCategories = [Id, QId, Sym, QSym, SymDot, SymMinus, SymMinusDot]

isPragmaToken :: Token -> Bool
isPragmaToken (Token cat _) = cat `elem` pragmaCategories

isPragmaEnd :: Token -> Bool
isPragmaEnd (Token cat _) = cat == PragmaEnd
>>>>>>> master

isTokenIdentifier :: Token -> Bool
isTokenIdentifier (Token cat _) = cat `elem` identCategories

whiteSpaceCategories :: [Category]
whiteSpaceCategories = [EOF, VSemicolon, VRightBrace]

pragmaCategories :: [Category]
pragmaCategories = [PragmaLanguage, PragmaOptions, PragmaEnd]

-- DECL Position

declPos :: Decl -> Position
declPos (InfixDecl        p _ _ _  ) = p
declPos (DataDecl         p _ _ _ _) = p
declPos (NewtypeDecl      p _ _ _ _) = p
declPos (TypeDecl         p _ _ _  ) = p
declPos (TypeSig          p _ _ _ _) = p
declPos (FunctionDecl     p _ _ _ _) = p
declPos (ForeignDecl      p _ _ _ _) = p
declPos (ExternalDecl     p _      ) = p
declPos (PatternDecl      p _ _ _ _) = p
declPos (FreeDecl         p _      ) = p
declPos (ClassDecl        p _ _ _ _) = p
declPos (InstanceDecl   p _ _ _ _ _) = p

lessDecl :: Decl -> Decl -> Bool
lessDecl = (<) `on` declPos

lessImportDecl :: ImportDecl -> ImportDecl -> Bool
lessImportDecl = (<) `on` (\ (ImportDecl p _ _ _ _) -> p)

qsort :: (a -> a -> Bool) -> [a] -> [a]
qsort _    []     = []
qsort less (x:xs) = concat [ qsort less [y | y <- xs, less y x]
                           , [x], qsort less [y | y <- xs, not $ less y x]]

-- -----------------------------------------------------------------------------
-- Extract all identifiers mentioned in the source code as a Code entity
-- -----------------------------------------------------------------------------

idsModule :: Module -> [Code]
idsModule (Module _ mid es is ds) =
  let hdrCodes = ModuleName mid : idsExportSpec es
      impCodes = concatMap idsImportDecl (qsort lessImportDecl is)
      dclCodes = concatMap idsDecl       (qsort lessDecl ds)
  in  map (addModuleIdent mid) $ hdrCodes ++ impCodes ++ dclCodes

<<<<<<< HEAD
--- @param parse-Exports
--- @param betterParse-Exports
mergeExports2codes :: [Export] -> [Export]  -> [Code]
mergeExports2codes [] _ = []
mergeExports2codes (e:es) xs = concatMap (export2codes xs)  (e:es)

export2codes :: [Export] -> Export -> [Code]
export2codes exports (Export qid)
    | length (filter checkDouble exports) /= 1 =
       [Identifier UnknownId qid]
    | otherwise =
       let [export] = (filter checkDouble exports) in
       export2c export
  where
    checkDouble (ExportTypeWith q _) = eqQualIdent qid q
    checkDouble (Export q) = eqQualIdent qid q
    checkDouble _ = False

    eqQualIdent q1 q2
      | q1 == q2 = True
      | not (isQualified q1) = unqualify q1 == unqualify q2
      | otherwise = False

    export2c (Export qid1) =
         [Function OtherFunctionKind qid1]
    export2c _ =
         [TypeConstructor TypeExport qid]

export2codes _ (ExportTypeWith qid idents) =
     TypeConstructor TypeExport qid : map (Function OtherFunctionKind . qualify) idents
export2codes _ (ExportTypeAll  qid) =
     [TypeConstructor TypeExport qid]
export2codes _ (ExportModule mid) =
     [ModuleName mid]

importDecl2codes :: ImportDecl -> [Code]
importDecl2codes (ImportDecl _ mid _ mModuleIdent importSpec) =
     [ModuleName mid] ++
     maybe [] ((:[]) . ModuleName) mModuleIdent ++
     maybe [] (importSpec2codes mid)  importSpec

decl2codes :: Decl -> [Code]
decl2codes (InfixDecl _ _ _ ops) = map (Function InfixFunction . qualify) ops
decl2codes (DataDecl _ d vs cds _der) =
     TypeConstructor TypeDecla (qualify d) :
     map (Identifier UnknownId . qualify) vs ++
     concatMap constrDecl2codes cds
decl2codes (NewtypeDecl _ _ _ _ _der) = []
decl2codes (TypeDecl _ t vs ty) =
     TypeConstructor TypeDecla (qualify t) :
     map (Identifier UnknownId . qualify) vs ++
     typeExpr2codes ty
decl2codes (TypeSig _ _ fs _cx ty) =
     map (Function TypSig . qualify) fs ++ typeExpr2codes ty
decl2codes (FunctionDecl _ _ _ _ eqs) = concatMap equation2codes eqs
decl2codes (ForeignDecl _ _ _ _ _) = []
decl2codes (ExternalDecl     _ fs) = map (Function FunDecl . qualify) fs
decl2codes (PatternDecl _ _ _ p rhs) =  pat2codes p ++ rhs2codes rhs
decl2codes (FreeDecl         _ vs) = map (Identifier IdDecl . qualify) vs
decl2codes (ClassDecl _ _scx _cls _tyvar _decls) = []
decl2codes (InstanceDecl _ _scx _cls _tycon _tyvars _decls) = [] 

equation2codes :: Equation -> [Code]
equation2codes (Equation _ lhs rhs) = lhs2codes lhs ++ rhs2codes rhs

lhs2codes :: Lhs -> [Code]
lhs2codes (FunLhs    f ps) = Function FunDecl (qualify f) : concatMap pat2codes ps
lhs2codes (OpLhs p1 op p2) = pat2codes p1 ++ [Function FunDecl $ qualify op] ++ pat2codes p2
lhs2codes (ApLhs   lhs ps) = lhs2codes lhs ++ concatMap pat2codes ps

rhs2codes :: Rhs -> [Code]
rhs2codes (SimpleRhs _ e ds) = expr2codes e ++ concatMap decl2codes ds
rhs2codes (GuardedRhs ce ds) = concatMap condExpr2codes ce ++ concatMap decl2codes ds

condExpr2codes :: CondExpr -> [Code]
condExpr2codes (CondExpr _ e1 e2) = expr2codes e1 ++ expr2codes e2

pat2codes :: Pattern -> [Code]
pat2codes (LiteralPattern          _) = []
pat2codes (NegativePattern       _ _) = []
pat2codes (VariablePattern         v) = [Identifier IdDecl (qualify v)]
pat2codes (ConstructorPattern qid ps)
  = ConstructorName ConstrPattern qid : concatMap pat2codes ps
pat2codes (InfixPattern    p1 qid p2)
  = pat2codes p1 ++ [ConstructorName ConstrPattern qid] ++ pat2codes p2
pat2codes (ParenPattern            p) = pat2codes p
pat2codes (TuplePattern         _ ps) = concatMap pat2codes ps
pat2codes (ListPattern          _ ps) = concatMap pat2codes ps
pat2codes (AsPattern             v p)
  = Function OtherFunctionKind (qualify v) : pat2codes p
pat2codes (LazyPattern           _ p) = pat2codes p
pat2codes (FunctionPattern    qid ps)
  = Function OtherFunctionKind qid : concatMap pat2codes ps
pat2codes (InfixFuncPattern  p1 f p2)
  = pat2codes p1 ++ [Function InfixFunction f] ++ pat2codes p2
pat2codes (RecordPattern         _ _) =
  internalError "SyntaxColoring.pat2codes: record pattern"

expr2codes :: Expression -> [Code]
expr2codes (Literal               _) = []
expr2codes (Variable          _ qid) = [Identifier IdOccur qid]
expr2codes (Constructor         qid) = [ConstructorName ConstrCall qid]
expr2codes (Paren                 e) = expr2codes e
expr2codes (Typed        _ e _cx ty) = expr2codes e ++ typeExpr2codes ty
expr2codes (Tuple              _ es) = concatMap expr2codes es
expr2codes (List               _ es) = concatMap expr2codes es
expr2codes (ListCompr     _ e stmts) = expr2codes e ++ concatMap statement2codes stmts
expr2codes (EnumFrom _            e) = expr2codes e
expr2codes (EnumFromThen _    e1 e2) = concatMap expr2codes [e1,e2]
expr2codes (EnumFromTo _      e1 e2) = concatMap expr2codes [e1,e2]
expr2codes (EnumFromThenTo _ e1 e2 e3) = concatMap expr2codes [e1,e2,e3]
expr2codes (UnaryMinus _    ident e) = Symbol (idName ident) : expr2codes e
expr2codes (Apply             e1 e2) = expr2codes e1 ++ expr2codes e2
expr2codes (InfixApply     e1 op e2) = expr2codes e1 ++ infixOp2codes op ++ expr2codes e2
expr2codes (LeftSection        e op) = expr2codes e ++ infixOp2codes op
expr2codes (RightSection       op e) = infixOp2codes op ++ expr2codes e
expr2codes (Lambda           _ ps e) = concatMap pat2codes ps ++ expr2codes e
expr2codes (Let                ds e) = concatMap decl2codes ds ++ expr2codes e
expr2codes (Do              stmts e) = concatMap statement2codes stmts ++ expr2codes e
expr2codes (IfThenElse   _ e1 e2 e3) = concatMap expr2codes [e1,e2,e3]
expr2codes (Case         _ _ e alts) = expr2codes e ++ concatMap alt2codes alts
expr2codes _ = internalError "SyntaxColoring.expr2codes: no pattern match"

infixOp2codes :: InfixOp -> [Code]
infixOp2codes (InfixOp   _ qid) = [Function InfixFunction qid]
infixOp2codes (InfixConstr qid) = [ConstructorName OtherConstrKind qid]

statement2codes :: Statement -> [Code]
statement2codes (StmtExpr   _ e) = expr2codes e
statement2codes (StmtDecl    ds) = concatMap decl2codes ds
statement2codes (StmtBind _ p e) = pat2codes p ++ expr2codes e

alt2codes :: Alt -> [Code]
alt2codes (Alt _ p rhs) = pat2codes p ++ rhs2codes rhs

constrDecl2codes :: ConstrDecl -> [Code]
constrDecl2codes (ConstrDecl _ _ c tys)
  = ConstructorName ConstrDecla (qualify c) : concatMap typeExpr2codes tys
constrDecl2codes (ConOpDecl _ _ ty1 op ty2)
  = typeExpr2codes ty1 ++ [ConstructorName ConstrDecla $ qualify op] ++ typeExpr2codes ty2

importSpec2codes :: ModuleIdent -> ImportSpec -> [Code]
importSpec2codes mid (Importing _ is) = concatMap (import2codes mid) is
importSpec2codes mid (Hiding _ is) = concatMap (import2codes mid) is

import2codes :: ModuleIdent -> Import -> [Code]
import2codes mid (Import ident) =
     [Function OtherFunctionKind $ qualifyWith mid ident]
import2codes mid (ImportTypeWith ident idents) =
     ConstructorName OtherConstrKind (qualifyWith mid ident) :
     map (Function OtherFunctionKind . qualifyWith mid) idents
import2codes mid (ImportTypeAll  ident) =
     [ConstructorName OtherConstrKind $ qualifyWith mid ident]

typeExpr2codes :: TypeExpr -> [Code]
typeExpr2codes (ConstructorType qid tys)
  = TypeConstructor TypeUse qid : concatMap typeExpr2codes tys
typeExpr2codes (VariableType          v) = [Identifier IdOccur (qualify v)]
typeExpr2codes (TupleType           tys) = concatMap typeExpr2codes tys
typeExpr2codes (ListType             ty) = typeExpr2codes ty
typeExpr2codes (ArrowType       ty1 ty2) = concatMap typeExpr2codes [ty1, ty2]
typeExpr2codes (RecordType          _ _) = internalError "SyntaxColoring.typeExpr2codes: Record pattern"
typeExpr2codes (SpecialConstructorType _tcon _tys) = []

showToken :: Token -> [Char]
showToken (Token Id           a) = showAttr a
showToken (Token QId          a) = showAttr a
showToken (Token Sym          a) = showAttr a
showToken (Token QSym         a) = showAttr a
showToken (Token IntTok       a) = showAttr a
showToken (Token FloatTok     a) = showAttr a
showToken (Token CharTok      a) = showAttr a
showToken (Token StringTok    a) = showAttr a
showToken (Token LeftParen    _) = "("
showToken (Token RightParen   _) = ")"
showToken (Token Semicolon    _) = ";"
showToken (Token LeftBrace    _) = "{"
showToken (Token RightBrace   _) = "}"
showToken (Token LeftBracket  _) = "["
showToken (Token RightBracket _) = "]"
showToken (Token Comma        _) = ","
showToken (Token Underscore   _) = "_"
showToken (Token Backquote    _) = "`"
showToken (Token VSemicolon   _) = ""
showToken (Token LeftBraceSemicolon _) = "{;"
showToken (Token VRightBrace  _) = ""
showToken (Token At           _) = "@"
showToken (Token Colon        _) = ":"
showToken (Token DotDot       _) = ".."
showToken (Token DoubleColon  _) = "::"
showToken (Token Equals       _) = "="
showToken (Token Backslash    _) = "\\"
showToken (Token Bar          _) = "|"
showToken (Token LeftArrow    _) = "<-"
showToken (Token RightArrow   _) = "->"
showToken (Token Tilde        _) = "~"
showToken (Token Bind         _) = ":="
showToken (Token Select       _) = ":>"
showToken (Token SymDot       _) = "."
showToken (Token SymMinus     _) = "-"
showToken (Token SymMinusDot  _) = "-."
showToken (Token DoubleArrow  _) = "=>" 
showToken (Token KW_case      _) = "case"
showToken (Token KW_class     _) = "class"
showToken (Token KW_data      _) = "data"
showToken (Token KW_deriving  _) = "deriving"
showToken (Token KW_do        _) = "do"
showToken (Token KW_else      _) = "else"
showToken (Token KW_external  _) = "external"
showToken (Token KW_fcase     _) = "fcase"
showToken (Token KW_foreign   _) = "foreign"
showToken (Token KW_free      _) = "free"
showToken (Token KW_if        _) = "if"
showToken (Token KW_import    _) = "import"
showToken (Token KW_in        _) = "in"
showToken (Token KW_infix     _) = "infix"
showToken (Token KW_infixl    _) = "infixl"
showToken (Token KW_infixr    _) = "infixr"
showToken (Token KW_instance  _) = "instance"
showToken (Token KW_let       _) = "let"
showToken (Token KW_module    _) = "module"
showToken (Token KW_newtype   _) = "newtype"
showToken (Token KW_of        _) = "of"
showToken (Token KW_then      _) = "then"
showToken (Token KW_type      _) = "type"
showToken (Token KW_where     _) = "where"
showToken (Token Id_as        _) = "as"
showToken (Token Id_ccall     _) = "ccall"
showToken (Token Id_forall    _) = "forall"
showToken (Token Id_hiding    _) = "hiding"
showToken (Token Id_interface _) = "interface"
showToken (Token Id_interfaceTypeClasses _) = "interfaceTypeClasses"
showToken (Token Id_primitive _) = "primitive"
showToken (Token Id_public    _) = "public"
showToken (Token Id_qualified _) = "qualified"
showToken (Token EOF          _) = ""
showToken (Token LineComment   (StringAttributes sv _)) = sv
showToken (Token LineComment   a                      ) = showAttr a
showToken (Token NestedComment (StringAttributes sv _)) = sv
showToken (Token NestedComment                       a) = showAttr a
=======
addModuleIdent :: ModuleIdent -> Code -> Code
addModuleIdent mid c@(Function x qid)
  | hasGlobalScope (unqualify qid) = Function x (qualQualify mid qid)
  | otherwise                      = c
addModuleIdent mid cn@(DataCons x qid)
  | not $ isQualified qid          = DataCons x (qualQualify mid qid)
  | otherwise                      = cn
addModuleIdent mid tc@(TypeCons x qid)
  | not $ isQualified qid          = TypeCons x (qualQualify mid qid)
  | otherwise                      = tc
addModuleIdent mid lb@(Label x qid)
  | not $ isQualified qid          = Label    x (qualQualify mid qid)
  | otherwise                      = lb
addModuleIdent _   c               = c

-- Exports

idsExportSpec ::  Maybe ExportSpec -> [Code]
idsExportSpec Nothing                 = []
idsExportSpec (Just (Exporting _ es)) = concatMap idsExport es

idsExport :: Export -> [Code]
idsExport (Export            qid) = [Function FuncExport qid]
idsExport (ExportTypeWith qid cs) = TypeCons TypeExport qid :
  map (DataCons ConsExport . qualify) cs
idsExport (ExportTypeAll     qid) = [TypeCons TypeExport qid]
idsExport (ExportModule      mid) = [ModuleName mid]

-- Imports

idsImportDecl :: ImportDecl -> [Code]
idsImportDecl (ImportDecl _ mid _ mAlias spec)
  = ModuleName mid : aliasCode ++ maybe [] (idsImportSpec mid) spec
  where aliasCode = maybe [] ((:[]) . ModuleName) mAlias

idsImportSpec :: ModuleIdent -> ImportSpec -> [Code]
idsImportSpec mid (Importing _ is) = concatMap (idsImport mid) is
idsImportSpec mid (Hiding    _ is) = concatMap (idsImport mid) is

idsImport :: ModuleIdent -> Import -> [Code]
idsImport mid (Import            i) =
  [Function FuncImport $ qualifyWith mid i]
idsImport mid (ImportTypeWith t cs) =
  TypeCons TypeImport (qualifyWith mid t) :
    map (DataCons ConsImport . qualifyWith mid) cs
idsImport mid (ImportTypeAll     t) =
  [TypeCons TypeImport $ qualifyWith mid t]

-- Declarations

idsDecl :: Decl -> [Code]
idsDecl (InfixDecl _   _ _ ops) = map (Function FuncInfix . qualify) ops
idsDecl (DataDecl   _ d vs cds) = TypeCons TypeDeclare (qualify d)
                                    :  map (Identifier IdDeclare . qualify) vs
                                    ++ concatMap idsConstrDecl cds
idsDecl (NewtypeDecl   _ _ _ _) = []
idsDecl (TypeDecl    _ t vs ty) = TypeCons TypeDeclare (qualify t)
                                    :  map (Identifier IdDeclare . qualify) vs
                                    ++ idsTypeExpr ty
idsDecl (TypeSig       _ fs ty) = map (Function FuncTypeSig . qualify) fs
                                    ++ idsTypeExpr ty
idsDecl (FunctionDecl  _ _ eqs) = concatMap idsEquation eqs
idsDecl (ForeignDecl _ _ _ _ _) = []
idsDecl (ExternalDecl     _ fs) = map (Function FuncDeclare . qualify) fs
idsDecl (PatternDecl   _ p rhs) = idsPat p ++ idsRhs rhs
idsDecl (FreeDecl         _ vs) = map (Identifier IdDeclare . qualify) vs

idsConstrDecl :: ConstrDecl -> [Code]
idsConstrDecl (ConstrDecl     _ _ c tys)
  = DataCons ConsDeclare (qualify c) : concatMap idsTypeExpr tys
idsConstrDecl (ConOpDecl _ _ ty1 op ty2)
  = idsTypeExpr ty1 ++ (DataCons ConsDeclare $ qualify op) : idsTypeExpr ty2

idsTypeExpr :: TypeExpr -> [Code]
idsTypeExpr (ConstructorType qid tys) = TypeCons TypeRefer qid :
                                           concatMap idsTypeExpr tys
idsTypeExpr (VariableType          v) = [Identifier IdRefer (qualify v)]
idsTypeExpr (TupleType           tys) = concatMap idsTypeExpr tys
idsTypeExpr (ListType             ty) = idsTypeExpr ty
idsTypeExpr (ArrowType       ty1 ty2) = concatMap idsTypeExpr [ty1, ty2]
idsTypeExpr (RecordType       fs mty) = concatMap idsFieldType fs
                                          ++ maybe [] idsTypeExpr mty

idsFieldType :: ([Ident], TypeExpr) -> [Code]
idsFieldType (fs, ty) = map (Label LabelDeclare . qualify) fs ++ idsTypeExpr ty

idsEquation :: Equation -> [Code]
idsEquation (Equation _ lhs rhs) = idsLhs lhs ++ idsRhs rhs

idsLhs :: Lhs -> [Code]
idsLhs (FunLhs    f ps) = Function FuncDeclare (qualify f) : concatMap idsPat ps
idsLhs (OpLhs p1 op p2) = idsPat p1 ++ [Function FuncDeclare $ qualify op] ++ idsPat p2
idsLhs (ApLhs   lhs ps) = idsLhs lhs ++ concatMap idsPat ps

idsRhs :: Rhs -> [Code]
idsRhs (SimpleRhs _ e ds) = idsExpr e ++ concatMap idsDecl ds
idsRhs (GuardedRhs ce ds) = concatMap idsCondExpr ce ++ concatMap idsDecl ds

idsCondExpr :: CondExpr -> [Code]
idsCondExpr (CondExpr _ e1 e2) = idsExpr e1 ++ idsExpr e2

idsPat :: Pattern -> [Code]
idsPat (LiteralPattern          _) = []
idsPat (NegativePattern       _ _) = []
idsPat (VariablePattern         v) = [Identifier IdDeclare (qualify v)]
idsPat (ConstructorPattern qid ps) = DataCons ConsPattern qid
                                      : concatMap idsPat ps
idsPat (InfixPattern    p1 qid p2) = idsPat p1 ++ DataCons ConsPattern qid : idsPat p2
idsPat (ParenPattern            p) = idsPat p
idsPat (TuplePattern         _ ps) = concatMap idsPat ps
idsPat (ListPattern          _ ps) = concatMap idsPat ps
idsPat (AsPattern             v p) = Identifier IdDeclare (qualify v) : idsPat p
idsPat (LazyPattern           _ p) = idsPat p
idsPat (FunctionPattern    qid ps) = Function FuncCall qid
                                      : concatMap idsPat ps
idsPat (InfixFuncPattern  p1 f p2) = idsPat p1 ++ Function FuncInfix f : idsPat p2
idsPat (RecordPattern         _ _) =
  internalError "SyntaxColoring.idsPat: record pattern"

idsExpr :: Expression -> [Code]
idsExpr (Literal                _) = []
idsExpr (Variable             qid)
  | isQualified qid                = [Function FuncCall qid]
  | hasGlobalScope (unqualify qid) = [Function FuncCall qid]
  | otherwise                      = [Identifier IdRefer qid]
idsExpr (Constructor          qid) = [DataCons ConsCall qid]
idsExpr (Paren                  e) = idsExpr e
idsExpr (Typed               e ty) = idsExpr e ++ idsTypeExpr ty
idsExpr (Tuple               _ es) = concatMap idsExpr es
idsExpr (List                _ es) = concatMap idsExpr es
idsExpr (ListCompr      _ e stmts) = idsExpr e ++ concatMap idsStmt stmts
idsExpr (EnumFrom               e) = idsExpr e
idsExpr (EnumFromThen       e1 e2) = concatMap idsExpr [e1, e2]
idsExpr (EnumFromTo         e1 e2) = concatMap idsExpr [e1, e2]
idsExpr (EnumFromThenTo  e1 e2 e3) = concatMap idsExpr [e1, e2, e3]
idsExpr (UnaryMinus       ident e) = Symbol (idName ident) : idsExpr e
idsExpr (Apply              e1 e2) = idsExpr e1 ++ idsExpr e2
idsExpr (InfixApply      e1 op e2) = idsExpr e1 ++ idsInfix op ++ idsExpr e2
idsExpr (LeftSection         e op) = idsExpr e ++ idsInfix op
idsExpr (RightSection        op e) = idsInfix op ++ idsExpr e
idsExpr (Lambda            _ ps e) = concatMap idsPat ps ++ idsExpr e
idsExpr (Let                 ds e) = concatMap idsDecl ds ++ idsExpr e
idsExpr (Do               stmts e) = concatMap idsStmt stmts ++ idsExpr e
idsExpr (IfThenElse    _ e1 e2 e3) = concatMap idsExpr [e1, e2, e3]
idsExpr (Case          _ _ e alts) = idsExpr e ++ concatMap idsAlt alts
idsExpr (RecordConstr          fs) = concatMap idsField fs
  where idsField (Field _ l e) = Label LabelRefer (qualify l) : idsExpr e
idsExpr (RecordSelection      e l) = idsExpr e ++ [Label LabelRefer (qualify l)]
idsExpr (RecordUpdate        fs e) = concatMap idsField fs ++ idsExpr e
  where idsField (Field _ l e') = Label LabelRefer (qualify l) : idsExpr e'

idsInfix :: InfixOp -> [Code]
idsInfix (InfixOp     qid) = [Function FuncInfix qid]
idsInfix (InfixConstr qid) = [DataCons ConsInfix qid]

idsStmt :: Statement -> [Code]
idsStmt (StmtExpr   _ e) = idsExpr e
idsStmt (StmtDecl    ds) = concatMap idsDecl ds
idsStmt (StmtBind _ p e) = idsPat p ++ idsExpr e

idsAlt :: Alt -> [Code]
idsAlt (Alt _ p rhs) = idsPat p ++ idsRhs rhs

-- -----------------------------------------------------------------------------
-- Conversion from a token to a string
-- -----------------------------------------------------------------------------

showToken :: Token -> String
showToken (Token Id                 a) = showAttr a
showToken (Token QId                a) = showAttr a
showToken (Token Sym                a) = showAttr a
showToken (Token QSym               a) = showAttr a
showToken (Token IntTok             a) = showAttr a
showToken (Token FloatTok           a) = showAttr a
showToken (Token CharTok            a) = showAttr a
showToken (Token StringTok          a) = showAttr a
showToken (Token LeftParen          _) = "("
showToken (Token RightParen         _) = ")"
showToken (Token Semicolon          _) = ";"
showToken (Token LeftBrace          _) = "{"
showToken (Token RightBrace         _) = "}"
showToken (Token LeftBracket        _) = "["
showToken (Token RightBracket       _) = "]"
showToken (Token Comma              _) = ","
showToken (Token Underscore         _) = "_"
showToken (Token Backquote          _) = "`"
showToken (Token VSemicolon         _) = ""
showToken (Token LeftBraceSemicolon _) = "{;"
showToken (Token VRightBrace        _) = ""
showToken (Token At                 _) = "@"
showToken (Token Colon              _) = ":"
showToken (Token DotDot             _) = ".."
showToken (Token DoubleColon        _) = "::"
showToken (Token Equals             _) = "="
showToken (Token Backslash          _) = "\\"
showToken (Token Bar                _) = "|"
showToken (Token LeftArrow          _) = "<-"
showToken (Token RightArrow         _) = "->"
showToken (Token Tilde              _) = "~"
showToken (Token Bind               _) = ":="
showToken (Token Select             _) = ":>"
showToken (Token SymDot             _) = "."
showToken (Token SymMinus           _) = "-"
showToken (Token SymMinusDot        _) = "-."
showToken (Token KW_case            _) = "case"
showToken (Token KW_data            _) = "data"
showToken (Token KW_do              _) = "do"
showToken (Token KW_else            _) = "else"
showToken (Token KW_external        _) = "external"
showToken (Token KW_fcase           _) = "fcase"
showToken (Token KW_foreign         _) = "foreign"
showToken (Token KW_free            _) = "free"
showToken (Token KW_if              _) = "if"
showToken (Token KW_import          _) = "import"
showToken (Token KW_in              _) = "in"
showToken (Token KW_infix           _) = "infix"
showToken (Token KW_infixl          _) = "infixl"
showToken (Token KW_infixr          _) = "infixr"
showToken (Token KW_let             _) = "let"
showToken (Token KW_module          _) = "module"
showToken (Token KW_newtype         _) = "newtype"
showToken (Token KW_of              _) = "of"
showToken (Token KW_then            _) = "then"
showToken (Token KW_type            _) = "type"
showToken (Token KW_where           _) = "where"
showToken (Token Id_as              _) = "as"
showToken (Token Id_ccall           _) = "ccall"
showToken (Token Id_forall          _) = "forall"
showToken (Token Id_hiding          _) = "hiding"
showToken (Token Id_interface       _) = "interface"
showToken (Token Id_primitive       _) = "primitive"
showToken (Token Id_qualified       _) = "qualified"
showToken (Token EOF                _) = ""
showToken (Token PragmaLanguage     _) = "{-# LANGUAGE"
showToken (Token PragmaOptions      a) = "{-# OPTIONS" ++ showAttr a
showToken (Token PragmaEnd          _) = "#-}"
showToken (Token LineComment   (StringAttributes s _)) = s
showToken (Token LineComment   a                     ) = showAttr a
showToken (Token NestedComment (StringAttributes s _)) = s
showToken (Token NestedComment                      a) = showAttr a
>>>>>>> master

showAttr :: Attributes -> [Char]
showAttr NoAttributes             = ""
showAttr (CharAttributes     c _) = show c
showAttr (IntAttributes      i _) = show i
showAttr (FloatAttributes    f _) = show f
showAttr (StringAttributes   s _) = show s
showAttr (IdentAttributes    m i)
  | null m    = show $ qualify                  (mkIdent i)
  | otherwise = show $ qualifyWith (mkMIdent m) (mkIdent i)
showAttr (OptionsAttributes mt s) = showTool mt ++ ' ' : s

showTool :: Maybe String -> String
showTool Nothing  = ""
showTool (Just t) = '_' : t
