test1: () => (constr(Prelude.Int Prelude.Float) -> constr(Prelude.Int Prelude.Float))
test2: () => (constr(Prelude.Int Prelude.Float) -> constr(Prelude.Int Prelude.Float))
test3: (C 0) => (0 -> 0)
test4: (C 0) => (0 -> 0)
test5a: () => (0 -> 0)
test5b: (C 0, E 0) => (0 -> 0)
test5c: (C 0, E 0) => (0 -> 0)
test5d: (C 0, E 0) => (0 -> Prelude.(,) 0 0)
test6: (C 0) => (0 -> 0)
test6b: () => (Prelude.() -> Prelude.())
test7: (C 0, E 0) => (0 -> 0)
test8a: (C 0, E 0, F 0) => (0 -> 0)
test8b: () => (0 -> 0)
test8c: (C 0) => (0 -> 0)
test8d: () => (0 -> Prelude.Bool)
test9a: (C 0, E 0) => (0 -> Prelude.(,) 0 0)
test9b: (C 0, E 0) => (0 -> 0)
test10: (C 0) => (0 -> 0)
test11: (C 0, E 0, F 0) => (0 -> 0)
test11b: (C 0, E 0, F 0) => (0 -> Prelude.Maybe Prelude.(,,) 0 Prelude.[] Prelude.Either 0 0 Prelude.(,,) Prelude.Bool 0 constr(Prelude.Int Prelude.Float))
test12: (C 0, E 0) => (0 -> 0)
test13: (C 0, E 0) => (0 -> 0)
test14: (C 0, E 0, F 0) => (0 -> 0)
test15: (E 0, F 0) => (0 -> 0)
test15b: (E 0, F 1) => (0 -> (1 -> Prelude.(,) 0 1))
test15c: (E 0, F 1) => (0 -> (1 -> Prelude.(,) 0 1))
test16: (E 0) => (0 -> 0)
test17: (E 0, F 0) => (0 -> Prelude.[] Prelude.Either 0 0)
test18: (E 0) => (0 -> 0)
test19: (C 1) => (0 -> 1)
test20: (C 0, E 0, F 0) => (0 -> 0)
